var documenterSearchIndex = {"docs":
[{"location":"#Sediment-Source-Analysis","page":"Sediment Source Analysis","title":"Sediment Source Analysis","text":"","category":"section"},{"location":"","page":"Sediment Source Analysis","title":"Sediment Source Analysis","text":"DocTestSetup = quote\n    using SedimentAnalysis\nend","category":"page"},{"location":"","page":"Sediment Source Analysis","title":"Sediment Source Analysis","text":"","category":"page"},{"location":"#Functions","page":"Sediment Source Analysis","title":"Functions","text":"","category":"section"},{"location":"","page":"Sediment Source Analysis","title":"Sediment Source Analysis","text":"combined_norm\nnnmtf\nplot_factors\nrel_error","category":"page"},{"location":"#SedimentAnalysis.MTF.combined_norm","page":"Sediment Source Analysis","title":"SedimentAnalysis.MTF.combined_norm","text":"combined_norm(u, v, ...)\n\nCompute the combined norm of the arguments as if all arguments were part of one large array.\n\nThis is equivilent to norm(cat(u, v, ...)), but this implimentation avoids creating anintermediate array.\n\nu = [3 0]\nv = [0 4 0]\ncombined_norm(u, v)\n\n# output\n\n5.0\n\n\n\n\n\n","category":"function"},{"location":"#SedimentAnalysis.MTF.nnmtf","page":"Sediment Source Analysis","title":"SedimentAnalysis.MTF.nnmtf","text":"nnmtf(Y::Abstract3Tensor, R::Integer; kwargs...)\n\nNon-negatively matrix-tensor factorizes an order 3 tensor Y with a given \"rank\" R.\n\nFactorizes Y approx C F where displaystyle Yijk approx sum_r=1^R Cir*Frjk and the factors C F geq 0 are nonnegative.\n\nNote there may NOT be a unique optimal solution\n\nArguments\n\nY::Abstract3Tensor: tensor to factorize\nR::Integer: rank to factorize Y (size(C)[2] and size(F)[1])\n\nKeywords\n\nmaxiter::Integer=100: maxmimum number of iterations\ntol::Real=1e-3: desiered tolerance for the -gradient's distance to the normal cone\nrescale::Bool=false: scale F at each iteration so that the 3-fiber sums are 1 (on average).\n\nThis also preprocesses the input Y in a similar way, and rescales the final F so Y=CF.\n\nplot_F::Integer=0: if not 0, plot F every plot_F iterations\nnames::AbstractVector{String}=String[]: names of the slices of F to use for ploting\n\nReturns\n\nC::Matrix{Float64}: the matrix C in the factorization Y ≈ C * F\nF::Array{Float64, 3}: the tensor F in the factorization Y ≈ C * F\nrel_errors::Vector{Float64}: relative errors at each iteration\nnorm_grad::Vector{Float64}: norm of the full gradient at each iteration\ndist_Ncone::Vector{Float64}: distance of the -gradient to the normal cone at each iteration\n\n\n\n\n\n","category":"function"},{"location":"#SedimentAnalysis.MTF.plot_factors","page":"Sediment Source Analysis","title":"SedimentAnalysis.MTF.plot_factors","text":"plot_factors(F, names; appendtitle=\"\")\n\nPlot each horizontal slice of F. Names give the name of each vertical slice.\n\n\n\n\n\n","category":"function"},{"location":"#SedimentAnalysis.MTF.rel_error","page":"Sediment Source Analysis","title":"SedimentAnalysis.MTF.rel_error","text":"rel_error(x, xhat)\n\nCompute the relative error between x (true value) and xhat (its approximation).\n\nThe relative error is given by:\n\nfraclVert x - hatx rVertlVert x rVert\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"Sediment Source Analysis","title":"Index","text":"","category":"section"},{"location":"","page":"Sediment Source Analysis","title":"Sediment Source Analysis","text":"","category":"page"}]
}
