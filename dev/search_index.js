var documenterSearchIndex = {"docs":
[{"location":"SedimentTools/#Sediment-Analysis-Tools","page":"Sediment Analysis Tools","title":"Sediment Analysis Tools","text":"","category":"section"},{"location":"MTF/#Matrix-Tensor-Factorization","page":"Matrix Tensor Factorization","title":"Matrix Tensor Factorization","text":"","category":"section"},{"location":"MTF/","page":"Matrix Tensor Factorization","title":"Matrix Tensor Factorization","text":"","category":"page"},{"location":"MTF/#Types","page":"Matrix Tensor Factorization","title":"Types","text":"","category":"section"},{"location":"MTF/","page":"Matrix Tensor Factorization","title":"Matrix Tensor Factorization","text":"Abstract3Tensor","category":"page"},{"location":"MTF/#SedimentAnalysis.MTF.Abstract3Tensor","page":"Matrix Tensor Factorization","title":"SedimentAnalysis.MTF.Abstract3Tensor","text":"Alias for an AbstractArray{T, 3}.\n\n\n\n\n\n","category":"type"},{"location":"MTF/#Functions","page":"Matrix Tensor Factorization","title":"Functions","text":"","category":"section"},{"location":"MTF/","page":"Matrix Tensor Factorization","title":"Matrix Tensor Factorization","text":"*(::AbstractMatrix, ::Abstract3Tensor)\ncombined_norm\nnnmtf\nplot_factors\nrel_error","category":"page"},{"location":"MTF/#Base.:*-Tuple{AbstractMatrix, AbstractArray{T, 3} where T}","page":"Matrix Tensor Factorization","title":"Base.:*","text":"Base.*(A::AbstractMatrix, B::Abstract3Tensor)\n\nComputes the Abstract3Tensor C where C_ijk = sum_l=1^L A_il * B_ljk.\n\nWhen the third dimention of B has length 1, this is equivilent to the usual matrix-matrix multiplication. For this reason, we resuse the same symbol.\n\nThis is equivilent to the 1-mode product B times_1 A.\n\n\n\n\n\n","category":"method"},{"location":"MTF/#SedimentAnalysis.MTF.combined_norm","page":"Matrix Tensor Factorization","title":"SedimentAnalysis.MTF.combined_norm","text":"combined_norm(u, v, ...)\n\nCompute the combined norm of the arguments as if all arguments were part of one large array.\n\nThis is equivilent to norm(cat(u, v, ...))`, but this implimentation avoids creating an intermediate array.\n\nu = [3 0]\nv = [0 4 0]\ncombined_norm(u, v)\n\n# output\n\n5.0\n\n\n\n\n\n","category":"function"},{"location":"MTF/#SedimentAnalysis.MTF.nnmtf","page":"Matrix Tensor Factorization","title":"SedimentAnalysis.MTF.nnmtf","text":"nnmtf(Y::Abstract3Tensor, R::Integer; kwargs...)\n\nNon-negatively matrix-tensor factorizes an order 3 tensor Y with a given \"rank\" R.\n\nFactorizes Y approx C F where displaystyle Yijk approx sum_r=1^R Cir*Frjk and the factors C F geq 0 are nonnegative.\n\nNote there may NOT be a unique optimal solution\n\nArguments\n\nY::Abstract3Tensor: tensor to factorize\nR::Integer: rank to factorize Y (size(C)[2] and size(F)[1])\n\nKeywords\n\nmaxiter::Integer=100: maxmimum number of iterations\ntol::Real=1e-3: desiered tolerance for the -gradient's distance to the normal cone\nrescale::Bool=false: scale F at each iteration so that the 3-fiber sums are 1 (on average). This also preprocesses the input Y in a similar way, and rescales the final F so Y=CF.\nplot_F::Integer=0: if not 0, plot F every plot_F iterations\nnames::AbstractVector{String}=String[]: names of the slices of F to use for ploting\n\nReturns\n\nC::Matrix{Float64}: the matrix C in the factorization Y ≈ C * F\nF::Array{Float64, 3}: the tensor F in the factorization Y ≈ C * F\nrel_errors::Vector{Float64}: relative errors at each iteration\nnorm_grad::Vector{Float64}: norm of the full gradient at each iteration\ndist_Ncone::Vector{Float64}: distance of the -gradient to the normal cone at each iteration\n\n\n\n\n\n","category":"function"},{"location":"MTF/#SedimentAnalysis.MTF.plot_factors","page":"Matrix Tensor Factorization","title":"SedimentAnalysis.MTF.plot_factors","text":"plot_factors(F, names; appendtitle=\"\")\n\nPlot each horizontal slice of F. Names give the name of each vertical slice.\n\n\n\n\n\n","category":"function"},{"location":"MTF/#SedimentAnalysis.MTF.rel_error","page":"Matrix Tensor Factorization","title":"SedimentAnalysis.MTF.rel_error","text":"rel_error(x, xhat)\n\nCompute the relative error between x (true value) and xhat (its approximation).\n\nThe relative error is given by:\n\nfraclVert x - hatx rVertlVert x rVert\n\n\n\n\n\n","category":"function"},{"location":"MTF/#Index","page":"Matrix Tensor Factorization","title":"Index","text":"","category":"section"},{"location":"MTF/","page":"Matrix Tensor Factorization","title":"Matrix Tensor Factorization","text":"","category":"page"},{"location":"#Sediment-Source-Analysis","page":"Sediment Source Analysis","title":"Sediment Source Analysis","text":"","category":"section"},{"location":"","page":"Sediment Source Analysis","title":"Sediment Source Analysis","text":"<!–","category":"page"},{"location":"","page":"Sediment Source Analysis","title":"Sediment Source Analysis","text":"DocTestSetup = quote\n    using SedimentAnalysis\nend","category":"page"},{"location":"","page":"Sediment Source Analysis","title":"Sediment Source Analysis","text":"–>","category":"page"},{"location":"","page":"Sediment Source Analysis","title":"Sediment Source Analysis","text":"Depth = 3","category":"page"},{"location":"#Importing","page":"Sediment Source Analysis","title":"Importing","text":"","category":"section"},{"location":"","page":"Sediment Source Analysis","title":"Sediment Source Analysis","text":"For now, clone the repo and install with julia> ] add SedimentAnalysis. To import, type using SedimentAnalysis at the top of your file to load both submodules. If only one of the modules is desired, type using SedimentAnalysis.XXX. The modules are built to be independent of each other so that (eventually) the MTF could be moved to an separate package altogether.","category":"page"},{"location":"#Submodules","page":"Sediment Source Analysis","title":"Submodules","text":"","category":"section"},{"location":"","page":"Sediment Source Analysis","title":"Sediment Source Analysis","text":"The two main submodules are MTF (Matrix Tensor Factorization) and SedimentTools.","category":"page"},{"location":"#MTF","page":"Sediment Source Analysis","title":"MTF","text":"","category":"section"},{"location":"","page":"Sediment Source Analysis","title":"Sediment Source Analysis","text":"Defines the main factorization function nnmtf and related mathematical functions. See the full documentation here Matrix Tensor Factorization.","category":"page"},{"location":"#SedimentTools","page":"Sediment Source Analysis","title":"SedimentTools","text":"","category":"section"},{"location":"","page":"Sediment Source Analysis","title":"Sediment Source Analysis","text":"Holds various types at the [Grain], and [Sink] level, importing ([read_raw_data]) and processing data ([make_densities]) functions, and additional methods of some Plots.jl functions for visualization with these custom types.","category":"page"},{"location":"#Index","page":"Sediment Source Analysis","title":"Index","text":"","category":"section"},{"location":"","page":"Sediment Source Analysis","title":"Sediment Source Analysis","text":"","category":"page"}]
}
